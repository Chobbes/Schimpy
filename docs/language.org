#+TITLE: Schimpy Documentation
#+AUTHOR: Calvin Beck
#+OPTIONS: ^:{}

* Data Types
** Input
   Single boolean value representing an input from a digital pin on an
   Arduino (TRUE is HIGH, and FALSE is LOW). Input values are updated
   sporadically, but they are guaranteed to not change within a
   function.
** Output
   Single boolean value for the output on a digital pin (TRUE is HIGH,
   and FALSE is LOW). Output variables act mostly the same as regular
   variables, except that their value will be reflected in the digital
   pins they are supposed to represent on the Arduino.
** Integers
   Ranges for integers need to be allowed. In particular we need to be
   able to have integers with only a few bits of state. The less state
   we waste the better.

   I think we can fairly easily support something like the stdint
   types from C, and we can support an arbitrary amount of bits from
   size 1 to size 32. For instance we can have int7_t and uint9_t.
** Byte
   Single 8-bit bytes. Can use ascii character literals.

   These are somewhat redundant with integers now that we have
   arbitrary bits for the integers. We might scrap these.
** Boolean
   True and false values.
* Expressions
** Simple expressions
   #+BEGIN_SRC bnf
     <exp> ::= <constant> | <variable> | <function-application>
   #+END_SRC
* Nodes
  These represent the main program which is a single thread of
  execution on a single processor. Each node contains a single state
  transition function, as well as some variables which represent the
  current state of the function. Each variable may only be altered
  once in the state transition function, and it may only be used in
  expressions before being modified -- this allows for the model
  checker code to be much simpler.
* Networks
  We need to be able to create networks in the language so we can
  automatically make models for entire networks, as well as make
  topology files for the Arduino emulator (and hopefully have
  everything immediately testable with Emulard).

  The basic idea is to assign names to the different nodes, and then
  specify the connections between them. We will use the names of the
  input / output variables to specify the connections.

  #+BEGIN_SRC lisp
    ;; Example for how to declare a network.
    (network
     ;; List of name, node pairs.
     ((read reader)
      (write writer))
    
     ;; List of connections output -> input
     ((read.ack write.ack)
      (write.bit read.bit)
      (write.lock read.lock)))
  #+END_SRC
* Macros
  Macros are essentially function calls, but when the model checking
  code is generated they are expanded into single expressions. As a
  result they can not be recursive, although they can call other
  macros.

  The advantage of using macros instead of functions is that they
  don't introduce any extra state. When you use functions, which can
  be recursive, we have to keep track of which function we are
  currently executing. Each function call will take an additional step
  in the model checker as well (which will affect specifications),
  whereas a macro will not. Macros will also guarantee referential
  transparency -- if they are called with the same arguments they will
  result in the same values.

  Note that the code that results from expanding a macro will result
  in the same restrictions that all other code will have, but
  otherwise they may be called in any place in the code. Functions are
  somewhat more restricted and may only be called in the tail, this
  prevents the model checking code from having to account for return
  positions.
** Scope
   Macros have the same scoping that functions do.
** Return Values
   Macros may return a list of values, but may only have one possible
   return type.
* Functions
  Functions are not expanded, and they might not be pure as the
  outputs and inputs are essentially pass by reference.
** Return Values
   Return values are completely necessary for functions because
   otherwise you can not return anything you read! This is complicated
   by the model needing to keep track of which variable to store the
   return value in.

   In NuSMV it is possible to implement function calls as modules, and
   use a "return value" variable in the module, as well as some
   boolean variable to represent when a function is done. By doing
   this we can just copy the module's return value into any variable
   that receives the functions value once the module is marked as
   being "done".
** Function Calling
*** Non-Recursive Functions
    In most cases you should try to use macros when you don't need to
    use recursion with functions. Macros can give you much of the same
    benefits, but they have the advantage of not requiring any
    additional state. While these may not be nearly as useful as their
    recursive counterparts our discussion of functions starts here for
    simplicity.

    The main difference between a non-recursive function and a macro
    is that the function can actually perform some I/O. A function
    call will cause input values to be read, and allow for all outputs
    to be written to.

    Since these functions are basically beefier macros we can call
    them from almost anywhere within another function. The one
    restriction is that all I/O must be done before any other function
    calls. The reason for this is that a function call can cause
    modifications to the I/O variables, so when the function returns
    they will not be in the same state as before. In fact any function
    that is not itself recursive may call any function in this manner
    whether or not the other function is recursive.

**** Multiple Calls
    A problem occurs when the same function is called multiple times
    in a function. For instance if we have an expression

    #+BEGIN_SRC lisp
      (eq (fact 0) (fact 1))
    #+END_SRC

    Then we will need additional storage to hold one of the results
    from the factorial computation while the second factorial
    computation is being performed. We need to know when exactly an
    additional temporary variable is necessary.

    It is clear that it is not always a necessity when a function is
    called multiple times, for instance in the expression:

    #+BEGIN_SRC lisp
      (if (eq 6 (fact 3)) (fact 0) (fact 1))
    #+END_SRC

    No additional state is necessary. The additional state is only
    necessary when we have to immediately perform operations on
    multiple results from the same function call, when the results for
    the function call are not stored in any additional variables
    beforehand.

    So, this means that when we have multiple branches of computation
    that each call a function once we don't need any additional
    state. Furthermore if we have, for instance, something like:

    #+BEGIN_SRC lisp
      (if true (eq (fact 0) (fact 1)) (eq (fact 1) (fact 2)))
    #+END_SRC

    Then while each branch needs a temporary variable to store a
    result from fact only one temporary variable is necessary since
    the computations may not occur at the same time.

    We need to, therefore, figure out how many times a function is
    called in each simple expression. The number of temporary
    variables needed for a function call is thus given by the largest
    number of times a function call can occur in a simple expression
    minus one (since one of the results can just be from the functions
    return value).
*** Recursive Functions
    Any function which calls itself must do so in a tail recursive
    fashion. A function may not indirectly recurse (e.g., *f* calls
    *g* which in turn calls *f*, because the previous state of *f*
    will still be needed).

    Otherwise the exact same restrictions for non-recursive functions
    holds.
* Examples
  Currently working on some examples for the language to figure out
  any oddities with the language, as well as how things should be
  translated.
** Communication
   Working on some communication examples. Want to show that it can be
   easy to write a little bit communication protocol that can share
   bytes and be reused easily. This was a problem with the previous
   iteration of the language.
*** Protocol
    The protocol in question involves a reader and a writer connected
    over a three bit channel. The connection is one way. The three
    channels are called *bit* (this is the data bit), *lock*, and
    *ack*. *bit* and *lock* communicate a single digital value from the
    writer to the reader. *ack* is used to send acknowledgments from
    the reader to the writer. The general idea is as follows:

    - The writer sets *bit*, and then sets *lock* to say "hey, there
      is a bit to read!"
    - The reader then looks at the value of *bit* and stores it. The
      reader then says "okay, got it!" by setting *ack*.
    - The reader then waits for the writer to unset *lock*. This is
      how the writer acknowledges that the reader has in fact gotten
      the value for bit.
    - The writer then waits for the reader to unset *ack*, which means
      that the reader is now in the position to accept more bits.

    This may then be repeated in order to read multiple bits in.
*** Reader
    Implemented in [[./examples/communication/reader.el][reader.el]], and an example NuSMV translation is given in [[./examples/communication/reader.smv][reader.smv]]

    One problem that came up is that I initially had this:

    #+BEGIN_SRC lisp
      ;; All this does is constantly read bytes
      (node reader
            ;; Port numbers below...
            (let ((byte (read_byte 2 3 4 8)))))
    #+END_SRC

    But in this case the initial value of "byte" isn't really well
    defined. There should probably be a rule that the value in a let
    binding must simplify down to a single expression. That is, it can
    be a macro call, a constant value, or maybe even defined as being
    another variable within the scope, but it may not be the value of
    a function call.

    It is also clear that nodes will need to have some state variables
    which can be modified. I think this is reasonable -- they are
    essentially the main variables describing the state of the FSM.

    This was changed to:

    #+BEGIN_SRC lisp
      ;; All this does is constantly read bytes
      (node reader
            ;; State variables are declared first with an initial
            ;; value. These may change after each iteration.
            ((byte our_byte) 0)
      
            ;; Port numbers below...
            (set our_byte (read_byte 2 3 4 8)))
    #+END_SRC

    So, now we declare state variables with an initial value, and can
    change them with "set".

    With how this is set up it may be difficult to know which pins are
    outputs... We should probably have to declare I/O pins,
    actually. Who knows if a pin is being used for input or output
    otherwise! So perhaps we should write nodes more like:

    #+BEGIN_SRC lisp
      ;; All this does is constantly read bytes
      (node reader
            ;; State variables are declared first with an initial
            ;; value. These may change after each iteration.
            (((byte our_byte) 0)
             ((input bit 2))  ; Initial values don't make sense for inputs.
             ((input lock 3))
             ((output ack 4) false))
      
            ;; Port numbers below...
            (set our_byte (read_byte bit lock ack 8)))
    #+END_SRC

    Where any I/O that the node uses must be declared within the
    node. Note that when we are reading in bytes we must use tail
    recursion!
*** Writer
    Implemented in [[./examples/communication/writer.el][writer.el]], and an example NuSMV translation is given in [[./examples/communication/writer.smv][writer.smv]]

    Writer is very similar to reader. One problem that came up was
    functions that just do I/O and don't have anything of value to
    return. For now the return values are just "()", which is the
    empty list.
** Factorial
   Factorial is a simple program to demonstrate tail call
   recursion. With tail call recursion "stack frames" can be reused,
   so no extra state is necessary.
* Some Assumptions
  - We will assume that numbers are completely random, which is not
    necessarily the case and may cause infinite arbitration in certain
    protocols (e.g., the token passing protocol).
  - Anything that occurs within a single state is atomic. For example
    in a single function call multiple outputs may be changed at
    once. In reality there will be a small delay between the changes
    in the outputs. This probably won't have any affect on anything,
    but it could potentially be an issue in the simple bit
    communication protocol if we set the data bit, and the lock bit in
    the same function.
  - There is an assumption that the single bit channels will always be
    read correctly.
