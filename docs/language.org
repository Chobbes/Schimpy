#+TITLE: Schimpy Documentation
#+AUTHOR: Calvin Beck
#+OPTIONS: ^:{}

* Data Types
** Input
   Single boolean value representing an input from a digital pin on an
   Arduino (TRUE is HIGH, and FALSE is LOW). Input values are updated
   sporadically, but they are guaranteed to not change within a
   function.
** Output
   Single boolean value for the output on a digital pin (TRUE is HIGH,
   and FALSE is LOW). Output variables act mostly the same as regular
   variables, except that their value will be reflected in the digital
   pins they are supposed to represent on the Arduino.
** Int
   16-bit integers
** Byte
   Single 8-bit bytes. Can use ascii character literals.
** Boolean
   True and false values.
* Nodes
  These represent the main program which is a single thread of
  execution on a single processor. Each node contains a single state
  transition function, as well as some variables which represent the
  current state of the function. Each variable may only be altered
  once in the state transition function, and it may only be used in
  expressions before being modified -- this allows for the model
  checker code to be much simpler.
* Macros
  Macros are essentially function calls, but when the model checking
  code is generated they are expanded into single expressions. As a
  result they can not be recursive, although they can call other
  macros.

  The advantage of using macros instead of functions is that they
  don't introduce any extra state. When you use functions, which can
  be recursive, we have to keep track of which function we are
  currently executing. Each function call will take an additional step
  in the model checker as well (which will affect specifications),
  whereas a macro will not. Macros will also guarantee referential
  transparency -- if they are called with the same arguments they will
  result in the same values.

  Note that the code that results from expanding a macro will result
  in the same restrictions that all other code will have, but
  otherwise they may be called in any place in the code. Functions are
  somewhat more restricted and may only be called in the tail, this
  prevents the model checking code from having to account for return
  positions.
** Scope
   Macros have the same scoping that functions do.
** Return Values
   Macros may return a list of values, but may only have one possible
   return type.
* Functions
  Functions are not expanded, and they might not be pure as the
  outputs and inputs are essentially pass by reference.
** Return Values
   Return values are completely necessary for functions because
   otherwise you can not return anything you read! This is complicated
   by the model needing to keep track of which variable to store the
   return value in.

   In NuSMV it is possible to implement function calls as modules, and
   use a "return value" variable in the module, as well as some
   boolean variable to represent when a function is done. By doing
   this we can just copy the module's return value into any variable
   that receives the functions value once the module is marked as
   being "done".
** Function Calling
*** Non-Recursive Functions
    In most cases you should try to use macros when you don't need to
    use recursion with functions. Macros can give you much of the same
    benefits, but they have the advantage of not requiring any
    additional state. While these may not be nearly as useful as their
    recursive counterparts our discussion of functions starts here for
    simplicity.

    The main difference between a non-recursive function and a macro
    is that the function can actually perform some I/O. A function
    call will cause input values to be read, and allow for all outputs
    to be written to.

    Since these functions are basically beefier macros we can call
    them from almost anywhere within another function. The one
    restriction is that all I/O must be done before any function
    call. The reason for this is that a function call can cause
    modifications to the I/O variables, so when the function returns
    they will not be in the same state as before. In fact any function
    that is not itself recursive may call any function in this manner
    whether or not the other function is recursive.
*** Recursive Functions
    Functions which call themselves, either directly or indirectly
    (for instance a function *f* could call another function *g*,
    where *g* calls *f*) need a bit of special treatment because we
    can not provide a proper call stack.
* Examples
  Currently working on some examples for the language to figure out
  any oddities with the language, as well as how things should be
  translated.
** Communication
   Working on some communication examples. Want to show that it can be
   easy to write a little bit communication protocol that can share
   bytes and be reused easily. This was a problem with the previous
   iteration of the language.
*** Protocol
    The protocol in question involves a reader and a writer connected
    over a three bit channel. The connection is one way. The three
    channels are called *bit* (this is the data bit), *lock*, and
    *ack*. *bit* and *lock* communicate a single digital value from the
    writer to the reader. *ack* is used to send acknowledgments from
    the reader to the writer. The general idea is as follows:

    - The writer sets *bit*, and then sets *lock* to say "hey, there
      is a bit to read!"
    - The reader then looks at the value of *bit* and stores it. The
      reader then says "okay, got it!" by setting *ack*.
    - The reader then waits for the writer to unset *lock*. This is
      how the writer acknowledges that the reader has in fact gotten
      the value for bit.
    - The writer then waits for the reader to unset *ack*, which means
      that the reader is now in the position to accept more bits.

    This may then be repeated in order to read multiple bits in.
*** Reader
    Implemented in [[./examples/communication/reader.el][reader.el]], and an example NuSMV translation is given in [[./examples/communication/reader.smv][reader.smv]]

    One problem that came up is that I initially had this:

    #+BEGIN_SRC lisp
      ;; All this does is constantly read bytes
      (node reader
            ;; Port numbers below...
            (let ((byte (read_byte 2 3 4 8)))))
    #+END_SRC

    But in this case the initial value of "byte" isn't really well
    defined. There should probably be a rule that the value in a let
    binding must simplify down to a single expression. That is, it can
    be a macro call, a constant value, or maybe even defined as being
    another variable within the scope, but it may not be the value of
    a function call.

    It is also clear that nodes will need to have some state variables
    which can be modified. I think this is reasonable -- they are
    essentially the main variables describing the state of the FSM.

    This was changed to:

    #+BEGIN_SRC lisp
      ;; All this does is constantly read bytes
      (node reader
            ;; State variables are declared first with an initial
            ;; value. These may change after each iteration.
            ((byte our_byte) 0)
      
            ;; Port numbers below...
            (set our_byte (read_byte 2 3 4 8)))
    #+END_SRC

    So, now we declare state variables with an initial value, and can
    change them with "set".

    With how this is set up it may be difficult to know which pins are
    outputs... We should probably have to declare I/O pins,
    actually. Who knows if a pin is being used for input or output
    otherwise! So perhaps we should write nodes more like:

    #+BEGIN_SRC lisp
      ;; All this does is constantly read bytes
      (node reader
            ;; State variables are declared first with an initial
            ;; value. These may change after each iteration.
            (((byte our_byte) 0)
             ((input bit 2))  ; Initial values don't make sense for inputs.
             ((input lock 3))
             ((output ack 4) false))
      
            ;; Port numbers below...
            (set our_byte (read_byte 2 3 4 8)))
    #+END_SRC

    Where any I/O that the node uses must be declared within the node.
** Factorial
   Factorial is a simple program to demonstrate tail call
   recursion. With tail call recursion "stack frames" can be reused,
   so no extra state is necessary.

